// Copyright 2018 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

const codeTemplate string = `-- Code generated by codegen/main.go. DO NOT EDIT.

local api_session = require "nakama.api.session"

local defold = require "nakama.engine.defold"
local json = require "nakama.util.json"
local log = require "nakama.util.log"

local M = {}

{{- range $defname, $definition := .Definitions }}
{{- $classname := $defname | title }}

--------------------------------------------------------------------------------
-- {{ $definition.Description | stripNewlines }}
function M.create_{{ $classname | pascalToSnake }}(
	{{- range $propname, $property := $definition.Properties }}
	{{- $luaType := luaType $property.Type }}
	{{- $varName := varName $propname $property.Type $property.Ref }}
	{{ $varName }}, -- '{{ $luaType }}' ({{ $property.Ref | cleanRef | pascalToSnake }}) {{ $property.Description }}
	{{- end }}
	_)
	{{- range $propname, $property := $definition.Properties }}
	{{- $luaType := luaType $property.Type }}
	{{- $varName := varName $propname $property.Type $property.Ref }}
	assert(not {{ $varName }} or type({{ $varName }}) == "{{ $luaType }}", "Argument '{{ $varName }}' must be 'nil' or of type '{{ $luaType }}'")
	{{- end }}
	return {
{{- range $propname, $property := $definition.Properties }}
{{- $luaType := luaType $property.Type }}
{{- $luaDef := luaDef $property.Type $property.Ref  }}
{{- $varName := varName $propname $property.Type $property.Ref }}
		{{ $propname }} = {{ $varName }} or {{ $luaDef }},
{{- end }}
	}
end

{{- end }}


--------------------------------------------------------------------------------
-- The low level client for the Nakama API.

local _http_fn = nil
local _config = {}

--
-- config.http_fn
-- config.base_uri
-- config.timeout
-- config.bearer_token
-- config.username
-- config.password
function M.init(config)
	assert(config, "You must provide a configuration")
	assert(config.base_uri, "You must provide a base URI")
	log("init()")

	_http_fn = config.http_fn or defold.http

	_config.base_uri = config.base_uri
	_config.bearer_token = config.bearer_token
	_config.username = config.username
	_config.password = config.password
	_config.timeout = config.timeout or 10
end

function M.sync(fn)
	local co = coroutine.create(fn)
	local ok, err = coroutine.resume(co)
	if not ok then
		log(err)
	end
end

function M.set_bearer_token(bearer_token)
	_config.bearer_token = bearer_token
end

{{- range $url, $path := .Paths }}
	{{- range $method, $operation := $path}}

-- {{ $operation.Summary | stripNewlines }}
function M.{{ $operation.OperationId | pascalToSnake }}_async(
    {{- range $i, $parameter := $operation.Parameters }}
	{{- $luaType := luaType $parameter.Type }}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
	{{- $varComment := varComment $parameter.Name $parameter.Type $parameter.Schema.Ref $parameter.Items.Type }}
	{{ $varName }}, -- Type: {{ $varComment }}
	{{- end }}
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("{{ $operation.OperationId | pascalToSnake }}_async()")

	local url_path = "{{- $url }}"
    {{- range $parameter := $operation.Parameters }}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
    {{- if eq $parameter.In "path" }}
	url_path = url_path.gsub("{{- print "{" $parameter.Name "}"}}", uri_encode({{ $varName }}))
    {{- end }}
    {{- end }}

	local query_params = {}
	{{- range $parameter := $operation.Parameters}}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
	{{- if eq $parameter.In "query"}}
	query_params["{{- $parameter.Name }}"] = {{ $varName }}
	{{- end}}
	{{- end}}

    {{- range $parameter := $operation.Parameters }}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
    {{- if eq $parameter.In "body" }}
	local post_data = json.encode({{ $varName }})
    {{- end }}
    {{- end }}

	_http_fn(_config, url_path, query_params, "{{- $method | uppercase }}", post_data, function(result)
		{{- if $operation.Responses.Ok.Schema.Ref }}
		if not result.error and {{ $operation.Responses.Ok.Schema.Ref | cleanRef | pascalToSnake }} then
			result = {{ $operation.Responses.Ok.Schema.Ref | cleanRef | pascalToSnake }}.create(result)
		end
		{{- end }}
		callback(result)
	end)
end
function M.{{ $operation.OperationId | pascalToSnake }}(
    {{- range $i,$parameter := $operation.Parameters }}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
	{{- $varComment := varComment $parameter.Name $parameter.Type $parameter.Schema.Ref $parameter.Items.Type }}
	{{ if $i }},{{ end }}{{ $varName }} -- Type: {{ $varComment }}
	{{- end }}
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.{{ $operation.OperationId | pascalToSnake }}_async(
		{{- range $parameter := $operation.Parameters }}
		{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
		{{ $varName }},
		{{- end }}
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end
	{{- end }}
{{- end }}

return M
`

func convertRefToClassName(input string) (className string) {
	cleanRef := strings.TrimPrefix(input, "#/definitions/")
	className = strings.Title(cleanRef)
	return
}

func stripNewlines(input string) (output string) {
	output = strings.Replace(input, "\n", " ", -1)
	return
}

func pascalToSnake(input string) (output string) {
	output = ""
	prev_low := false
	for _, v := range input {
		is_cap := v >= 'A' && v <= 'Z'
		is_low := v >= 'a' && v <= 'z'
		if is_cap && prev_low {
			output = output + "_"
		}
		output += strings.ToLower(string(v))
		prev_low = is_low
	}
	return
}

// Parameter type to Lua type
func luaType(p_type string) (out string) {
	switch p_type {
		case "integer": out = "number"
		case "string": out = "string"
		case "boolean": out = "boolean"
		case "array": out = "table"
		case "object": out = "table"
		default: out = "table"
	}
	return
}

// Default value for Lua types
func luaDef(p_type string, p_ref string) (out string) {
	switch(p_type) {
		case "integer": out = "0"
		case "string": out = "\"\""
		case "boolean": out = "false"
		case "array": out = "{}"
		case "object": out = "{ _ = '' }"
		default: out = "M.create_" + pascalToSnake(convertRefToClassName(p_ref)) + "()"
	}
	return
}

// Lua variable name from name, type and ref
func varName(p_name string, p_type string, p_ref string) (out string) {
	switch(p_type) {
		case "integer": out = p_name + "_int"
		case "string": out = p_name + "_str"
		case "boolean": out = p_name + "_bool"
		case "array": out = p_name + "_arr"
		case "object": out = p_name + "_obj"
		default: out = p_name + "_" + pascalToSnake(convertRefToClassName(p_ref))
	}
	return
}

func varComment(p_name string, p_type string, p_ref string, p_item_type string) (out string) {
	switch(p_type) {
		case "integer": out = "number"
		case "string": out = "string"
		case "boolean": out = "boolean"
		case "array": out = "table (" + luaType(p_item_type) + ")"
		case "object": out = "table (object)"
		default: out = "table (" + pascalToSnake(convertRefToClassName(p_ref)) + ")"
	}
	return
}


func main() {
	// Argument flags
	var output = flag.String("output", "", "The output for generated code.")
	flag.Parse()

	inputs := flag.Args()
	if len(inputs) < 1 {
		fmt.Printf("No input file found: %s\n\n", inputs)
		fmt.Println("openapi-gen [flags] inputs...")
		flag.PrintDefaults()
		return
	}

	input := inputs[0]
	content, err := ioutil.ReadFile(input)
	if err != nil {
		fmt.Printf("Unable to read file: %s\n", err)
		return
	}

	var schema struct {
		Paths map[string]map[string]struct {
			Summary     string
			OperationId string
			Responses   struct {
				Ok struct {
					Schema struct {
						Ref string `json:"$ref"`
					}
				} `json:"200"`
			}
			Parameters []struct {
				Name     string
				In       string
				Required bool
				Type     string   // used with primitives
				Items    struct { // used with type "array"
					Type string
				}
				Schema struct { // used with http body
					Type string
					Ref  string `json:"$ref"`
				}
                Format   string // used with type "boolean"
			}
			Security []map[string][]struct {
			}
		}
		Definitions map[string]struct {
			Properties map[string]struct {
				Type  string
				Ref   string   `json:"$ref"` // used with object
				Items struct { // used with type "array"
					Type string
					Ref  string `json:"$ref"`
				}
				AdditionalProperties struct {
					Type string // used with type "map"
				}
				Format      string // used with type "boolean"
				Description string
			}
			Description string
		}
	}

	if err := json.Unmarshal(content, &schema); err != nil {
		fmt.Printf("Unable to decode input %s : %s\n", input, err)
		return
	}

	fmap := template.FuncMap{
		"cleanRef": convertRefToClassName,
		"stripNewlines": stripNewlines,
		"title": strings.Title,
		"uppercase": strings.ToUpper,
		"pascalToSnake": pascalToSnake,
		"luaType": luaType,
		"luaDef": luaDef,
		"varName": varName,
		"varComment": varComment,
	}
	tmpl, err := template.New(input).Funcs(fmap).Parse(codeTemplate)
	if err != nil {
		fmt.Printf("Template parse error: %s\n", err)
		return
	}

	if len(*output) < 1 {
		tmpl.Execute(os.Stdout, schema)
		return
	}

	f, err := os.Create(*output)
	if err != nil {
		fmt.Printf("Unable to create file: %s\n", err)
		return
	}
	defer f.Close()

	writer := bufio.NewWriter(f)
	tmpl.Execute(writer, schema)
	writer.Flush()
}
