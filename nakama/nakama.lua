-- Code generated by codegen/main.go. DO NOT EDIT.

local api_session = require "nakama.api.session"

local defold = require "nakama.engine.defold"
local json = require "nakama.util.json"
local log = require "nakama.util.log"

local M = {}

--------------------------------------------------------------------------------
-- A single user-role pair.
function M.create_group_user_list_group_user(
	state_int, -- 'number' () Their relationship to the group.
	user_api_user, -- 'table' (api_user) User.
	_)
	assert(not state_int or type(state_int) == "number", "Argument 'state_int' must be 'nil' or of type 'number'")
	assert(not user_api_user or type(user_api_user) == "table", "Argument 'user_api_user' must be 'nil' or of type 'table'")
	return {
		state = state_int or 0,
		user = user_api_user or M.create_api_user(),
	}
end

--------------------------------------------------------------------------------
-- A single group-role pair.
function M.create_user_group_list_user_group(
	group_api_group, -- 'table' (api_group) Group.
	state_int, -- 'number' () The user's relationship to the group.
	_)
	assert(not group_api_group or type(group_api_group) == "table", "Argument 'group_api_group' must be 'nil' or of type 'table'")
	assert(not state_int or type(state_int) == "number", "Argument 'state_int' must be 'nil' or of type 'number'")
	return {
		group = group_api_group or M.create_api_group(),
		state = state_int or 0,
	}
end

--------------------------------------------------------------------------------
-- Record values to write.
function M.create_write_leaderboard_record_request_leaderboard_record_write(
	metadata_str, -- 'string' () Optional record metadata.
	score_str, -- 'string' () The score value to submit.
	subscore_str, -- 'string' () An optional secondary value.
	_)
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not score_str or type(score_str) == "string", "Argument 'score_str' must be 'nil' or of type 'string'")
	assert(not subscore_str or type(subscore_str) == "string", "Argument 'subscore_str' must be 'nil' or of type 'string'")
	return {
		metadata = metadata_str or "",
		score = score_str or "",
		subscore = subscore_str or "",
	}
end

--------------------------------------------------------------------------------
-- Record values to write.
function M.create_write_tournament_record_request_tournament_record_write(
	metadata_str, -- 'string' () A JSON object of additional properties (optional).
	score_str, -- 'string' () The score value to submit.
	subscore_str, -- 'string' () An optional secondary value.
	_)
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not score_str or type(score_str) == "string", "Argument 'score_str' must be 'nil' or of type 'string'")
	assert(not subscore_str or type(subscore_str) == "string", "Argument 'subscore_str' must be 'nil' or of type 'string'")
	return {
		metadata = metadata_str or "",
		score = score_str or "",
		subscore = subscore_str or "",
	}
end

--------------------------------------------------------------------------------
-- A user with additional account details. Always the current user.
function M.create_api_account(
	custom_id_str, -- 'string' () The custom id in the user's account.
	devices_arr, -- 'table' () The devices which belong to the user's account.
	email_str, -- 'string' () The email address of the user.
	user_api_user, -- 'table' (api_user) The user object.
	verify_time_str, -- 'string' () The UNIX time when the user's email was verified.
	wallet_str, -- 'string' () The user's wallet data.
	_)
	assert(not custom_id_str or type(custom_id_str) == "string", "Argument 'custom_id_str' must be 'nil' or of type 'string'")
	assert(not devices_arr or type(devices_arr) == "table", "Argument 'devices_arr' must be 'nil' or of type 'table'")
	assert(not email_str or type(email_str) == "string", "Argument 'email_str' must be 'nil' or of type 'string'")
	assert(not user_api_user or type(user_api_user) == "table", "Argument 'user_api_user' must be 'nil' or of type 'table'")
	assert(not verify_time_str or type(verify_time_str) == "string", "Argument 'verify_time_str' must be 'nil' or of type 'string'")
	assert(not wallet_str or type(wallet_str) == "string", "Argument 'wallet_str' must be 'nil' or of type 'string'")
	return {
		custom_id = custom_id_str or "",
		devices = devices_arr or {},
		email = email_str or "",
		user = user_api_user or M.create_api_user(),
		verify_time = verify_time_str or "",
		wallet = wallet_str or "",
	}
end

--------------------------------------------------------------------------------
-- Send a custom ID to the server. Used with authenticate/link/unlink.
function M.create_api_account_custom(
	id_str, -- 'string' () A custom identifier.
	vars_obj, -- 'table' () Extra information that will be bundled in the session token.
	_)
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		id = id_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
-- Send a device to the server. Used with authenticate/link/unlink and user.
function M.create_api_account_device(
	id_str, -- 'string' () A device identifier. Should be obtained by a platform-specific device API.
	vars_obj, -- 'table' () Extra information that will be bundled in the session token.
	_)
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		id = id_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
-- Send an email with password to the server. Used with authenticate/link/unlink.
function M.create_api_account_email(
	email_str, -- 'string' () A valid RFC-5322 email address.
	password_str, -- 'string' () A password for the user account.
	vars_obj, -- 'table' () Extra information that will be bundled in the session token.
	_)
	assert(not email_str or type(email_str) == "string", "Argument 'email_str' must be 'nil' or of type 'string'")
	assert(not password_str or type(password_str) == "string", "Argument 'password_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		email = email_str or "",
		password = password_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
-- Send a Facebook token to the server. Used with authenticate/link/unlink.
function M.create_api_account_facebook(
	token_str, -- 'string' () The OAuth token received from Facebook to access their profile API.
	vars_obj, -- 'table' () Extra information that will be bundled in the session token.
	_)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
-- Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink.
function M.create_api_account_facebook_instant_game(
	signed_player_info_str, -- 'string' () 
	vars_obj, -- 'table' () Extra information that will be bundled in the session token.
	_)
	assert(not signed_player_info_str or type(signed_player_info_str) == "string", "Argument 'signed_player_info_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		signed_player_info = signed_player_info_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
-- Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
function M.create_api_account_game_center(
	bundle_id_str, -- 'string' () Bundle ID (generated by GameCenter).
	player_id_str, -- 'string' () Player ID (generated by GameCenter).
	public_key_url_str, -- 'string' () The URL for the public encryption key.
	salt_str, -- 'string' () A random "NSString" used to compute the hash and keep it randomized.
	signature_str, -- 'string' () The verification signature data generated.
	timestamp_seconds_str, -- 'string' () Time since UNIX epoch when the signature was created.
	vars_obj, -- 'table' () Extra information that will be bundled in the session token.
	_)
	assert(not bundle_id_str or type(bundle_id_str) == "string", "Argument 'bundle_id_str' must be 'nil' or of type 'string'")
	assert(not player_id_str or type(player_id_str) == "string", "Argument 'player_id_str' must be 'nil' or of type 'string'")
	assert(not public_key_url_str or type(public_key_url_str) == "string", "Argument 'public_key_url_str' must be 'nil' or of type 'string'")
	assert(not salt_str or type(salt_str) == "string", "Argument 'salt_str' must be 'nil' or of type 'string'")
	assert(not signature_str or type(signature_str) == "string", "Argument 'signature_str' must be 'nil' or of type 'string'")
	assert(not timestamp_seconds_str or type(timestamp_seconds_str) == "string", "Argument 'timestamp_seconds_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		bundle_id = bundle_id_str or "",
		player_id = player_id_str or "",
		public_key_url = public_key_url_str or "",
		salt = salt_str or "",
		signature = signature_str or "",
		timestamp_seconds = timestamp_seconds_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
-- Send a Google token to the server. Used with authenticate/link/unlink.
function M.create_api_account_google(
	token_str, -- 'string' () The OAuth token received from Google to access their profile API.
	vars_obj, -- 'table' () Extra information that will be bundled in the session token.
	_)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
-- Send a Steam token to the server. Used with authenticate/link/unlink.
function M.create_api_account_steam(
	token_str, -- 'string' () The account token received from Steam to access their profile API.
	vars_obj, -- 'table' () Extra information that will be bundled in the session token.
	_)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
-- A message sent on a channel.
function M.create_api_channel_message(
	channel_id_str, -- 'string' () The channel this message belongs to.
	code_int, -- 'number' () The code representing a message type or category.
	content_str, -- 'string' () The content payload.
	create_time_str, -- 'string' () The UNIX time when the message was created.
	group_id_str, -- 'string' () The ID of the group, or an empty string if this message was not sent through a group channel.
	message_id_str, -- 'string' () The unique ID of this message.
	persistent_bool, -- 'boolean' () True if the message was persisted to the channel's history, false otherwise.
	room_name_str, -- 'string' () The name of the chat room, or an empty string if this message was not sent through a chat room.
	sender_id_str, -- 'string' () Message sender, usually a user ID.
	update_time_str, -- 'string' () The UNIX time when the message was last updated.
	user_id_one_str, -- 'string' () The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
	user_id_two_str, -- 'string' () The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
	username_str, -- 'string' () The username of the message sender, if any.
	_)
	assert(not channel_id_str or type(channel_id_str) == "string", "Argument 'channel_id_str' must be 'nil' or of type 'string'")
	assert(not code_int or type(code_int) == "number", "Argument 'code_int' must be 'nil' or of type 'number'")
	assert(not content_str or type(content_str) == "string", "Argument 'content_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not group_id_str or type(group_id_str) == "string", "Argument 'group_id_str' must be 'nil' or of type 'string'")
	assert(not message_id_str or type(message_id_str) == "string", "Argument 'message_id_str' must be 'nil' or of type 'string'")
	assert(not persistent_bool or type(persistent_bool) == "boolean", "Argument 'persistent_bool' must be 'nil' or of type 'boolean'")
	assert(not room_name_str or type(room_name_str) == "string", "Argument 'room_name_str' must be 'nil' or of type 'string'")
	assert(not sender_id_str or type(sender_id_str) == "string", "Argument 'sender_id_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not user_id_one_str or type(user_id_one_str) == "string", "Argument 'user_id_one_str' must be 'nil' or of type 'string'")
	assert(not user_id_two_str or type(user_id_two_str) == "string", "Argument 'user_id_two_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		channel_id = channel_id_str or "",
		code = code_int or 0,
		content = content_str or "",
		create_time = create_time_str or "",
		group_id = group_id_str or "",
		message_id = message_id_str or "",
		persistent = persistent_bool or false,
		room_name = room_name_str or "",
		sender_id = sender_id_str or "",
		update_time = update_time_str or "",
		user_id_one = user_id_one_str or "",
		user_id_two = user_id_two_str or "",
		username = username_str or "",
	}
end

--------------------------------------------------------------------------------
-- A list of channel messages, usually a result of a list operation.
function M.create_api_channel_message_list(
	messages_arr, -- 'table' () A list of messages.
	next_cursor_str, -- 'string' () The cursor to send when retireving the next page, if any.
	prev_cursor_str, -- 'string' () The cursor to send when retrieving the previous page, if any.
	_)
	assert(not messages_arr or type(messages_arr) == "table", "Argument 'messages_arr' must be 'nil' or of type 'table'")
	assert(not next_cursor_str or type(next_cursor_str) == "string", "Argument 'next_cursor_str' must be 'nil' or of type 'string'")
	assert(not prev_cursor_str or type(prev_cursor_str) == "string", "Argument 'prev_cursor_str' must be 'nil' or of type 'string'")
	return {
		messages = messages_arr or {},
		next_cursor = next_cursor_str or "",
		prev_cursor = prev_cursor_str or "",
	}
end

--------------------------------------------------------------------------------
-- Create a group with the current user as owner.
function M.create_api_create_group_request(
	avatar_url_str, -- 'string' () A URL for an avatar image.
	description_str, -- 'string' () A description for the group.
	lang_tag_str, -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	max_count_int, -- 'number' () Maximum number of group members.
	name_str, -- 'string' () A unique name for the group.
	open_bool, -- 'boolean' () Mark a group as open or not where only admins can accept members.
	_)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not max_count_int or type(max_count_int) == "number", "Argument 'max_count_int' must be 'nil' or of type 'number'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not open_bool or type(open_bool) == "boolean", "Argument 'open_bool' must be 'nil' or of type 'boolean'")
	return {
		avatar_url = avatar_url_str or "",
		description = description_str or "",
		lang_tag = lang_tag_str or "",
		max_count = max_count_int or 0,
		name = name_str or "",
		open = open_bool or false,
	}
end

--------------------------------------------------------------------------------
-- Storage objects to delete.
function M.create_api_delete_storage_object_id(
	collection_str, -- 'string' () The collection which stores the object.
	key_str, -- 'string' () The key of the object within the collection.
	version_str, -- 'string' () The version hash of the object.
	_)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		key = key_str or "",
		version = version_str or "",
	}
end

--------------------------------------------------------------------------------
-- Batch delete storage objects.
function M.create_api_delete_storage_objects_request(
	object_ids_arr, -- 'table' () Batch of storage objects.
	_)
	assert(not object_ids_arr or type(object_ids_arr) == "table", "Argument 'object_ids_arr' must be 'nil' or of type 'table'")
	return {
		object_ids = object_ids_arr or {},
	}
end

--------------------------------------------------------------------------------
-- Represents an event to be passed through the server to registered event handlers.
function M.create_api_event(
	external_bool, -- 'boolean' () True if the event came directly from a client call, false otherwise.
	name_str, -- 'string' () An event name, type, category, or identifier.
	properties_obj, -- 'table' () Arbitrary event property values.
	timestamp_str, -- 'string' () The time when the event was triggered.
	_)
	assert(not external_bool or type(external_bool) == "boolean", "Argument 'external_bool' must be 'nil' or of type 'boolean'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not properties_obj or type(properties_obj) == "table", "Argument 'properties_obj' must be 'nil' or of type 'table'")
	assert(not timestamp_str or type(timestamp_str) == "string", "Argument 'timestamp_str' must be 'nil' or of type 'string'")
	return {
		external = external_bool or false,
		name = name_str or "",
		properties = properties_obj or { _ = '' },
		timestamp = timestamp_str or "",
	}
end

--------------------------------------------------------------------------------
-- A friend of a user.
function M.create_api_friend(
	state_int, -- 'number' () The friend status.
	user_api_user, -- 'table' (api_user) The user object.
	_)
	assert(not state_int or type(state_int) == "number", "Argument 'state_int' must be 'nil' or of type 'number'")
	assert(not user_api_user or type(user_api_user) == "table", "Argument 'user_api_user' must be 'nil' or of type 'table'")
	return {
		state = state_int or 0,
		user = user_api_user or M.create_api_user(),
	}
end

--------------------------------------------------------------------------------
-- A collection of zero or more friends of the user.
function M.create_api_friend_list(
	cursor_str, -- 'string' () Cursor for the next page of results, if any.
	friends_arr, -- 'table' () The Friend objects.
	_)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not friends_arr or type(friends_arr) == "table", "Argument 'friends_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		friends = friends_arr or {},
	}
end

--------------------------------------------------------------------------------
-- A group in the server.
function M.create_api_group(
	avatar_url_str, -- 'string' () A URL for an avatar image.
	create_time_str, -- 'string' () The UNIX time when the group was created.
	creator_id_str, -- 'string' () The id of the user who created the group.
	description_str, -- 'string' () A description for the group.
	edge_count_int, -- 'number' () The current count of all members in the group.
	id_str, -- 'string' () The id of a group.
	lang_tag_str, -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	max_count_int, -- 'number' () The maximum number of members allowed.
	metadata_str, -- 'string' () Additional information stored as a JSON object.
	name_str, -- 'string' () The unique name of the group.
	open_bool, -- 'boolean' () Anyone can join open groups, otherwise only admins can accept members.
	update_time_str, -- 'string' () The UNIX time when the group was last updated.
	_)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not creator_id_str or type(creator_id_str) == "string", "Argument 'creator_id_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not edge_count_int or type(edge_count_int) == "number", "Argument 'edge_count_int' must be 'nil' or of type 'number'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not max_count_int or type(max_count_int) == "number", "Argument 'max_count_int' must be 'nil' or of type 'number'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not open_bool or type(open_bool) == "boolean", "Argument 'open_bool' must be 'nil' or of type 'boolean'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	return {
		avatar_url = avatar_url_str or "",
		create_time = create_time_str or "",
		creator_id = creator_id_str or "",
		description = description_str or "",
		edge_count = edge_count_int or 0,
		id = id_str or "",
		lang_tag = lang_tag_str or "",
		max_count = max_count_int or 0,
		metadata = metadata_str or "",
		name = name_str or "",
		open = open_bool or false,
		update_time = update_time_str or "",
	}
end

--------------------------------------------------------------------------------
-- One or more groups returned from a listing operation.
function M.create_api_group_list(
	cursor_str, -- 'string' () A cursor used to get the next page.
	groups_arr, -- 'table' () One or more groups.
	_)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not groups_arr or type(groups_arr) == "table", "Argument 'groups_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		groups = groups_arr or {},
	}
end

--------------------------------------------------------------------------------
-- A list of users belonging to a group, along with their role.
function M.create_api_group_user_list(
	cursor_str, -- 'string' () Cursor for the next page of results, if any.
	group_users_arr, -- 'table' () User-role pairs for a group.
	_)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not group_users_arr or type(group_users_arr) == "table", "Argument 'group_users_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		group_users = group_users_arr or {},
	}
end

--------------------------------------------------------------------------------
-- Represents a complete leaderboard record with all scores and associated metadata.
function M.create_api_leaderboard_record(
	create_time_str, -- 'string' () The UNIX time when the leaderboard record was created.
	expiry_time_str, -- 'string' () The UNIX time when the leaderboard record expires.
	leaderboard_id_str, -- 'string' () The ID of the leaderboard this score belongs to.
	max_num_score_int, -- 'number' () The maximum number of score updates allowed by the owner.
	metadata_str, -- 'string' () Metadata.
	num_score_int, -- 'number' () The number of submissions to this score record.
	owner_id_str, -- 'string' () The ID of the score owner, usually a user or group.
	rank_str, -- 'string' () The rank of this record.
	score_str, -- 'string' () The score value.
	subscore_str, -- 'string' () An optional subscore value.
	update_time_str, -- 'string' () The UNIX time when the leaderboard record was updated.
	username_str, -- 'string' () The username of the score owner, if the owner is a user.
	_)
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not expiry_time_str or type(expiry_time_str) == "string", "Argument 'expiry_time_str' must be 'nil' or of type 'string'")
	assert(not leaderboard_id_str or type(leaderboard_id_str) == "string", "Argument 'leaderboard_id_str' must be 'nil' or of type 'string'")
	assert(not max_num_score_int or type(max_num_score_int) == "number", "Argument 'max_num_score_int' must be 'nil' or of type 'number'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not num_score_int or type(num_score_int) == "number", "Argument 'num_score_int' must be 'nil' or of type 'number'")
	assert(not owner_id_str or type(owner_id_str) == "string", "Argument 'owner_id_str' must be 'nil' or of type 'string'")
	assert(not rank_str or type(rank_str) == "string", "Argument 'rank_str' must be 'nil' or of type 'string'")
	assert(not score_str or type(score_str) == "string", "Argument 'score_str' must be 'nil' or of type 'string'")
	assert(not subscore_str or type(subscore_str) == "string", "Argument 'subscore_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		create_time = create_time_str or "",
		expiry_time = expiry_time_str or "",
		leaderboard_id = leaderboard_id_str or "",
		max_num_score = max_num_score_int or 0,
		metadata = metadata_str or "",
		num_score = num_score_int or 0,
		owner_id = owner_id_str or "",
		rank = rank_str or "",
		score = score_str or "",
		subscore = subscore_str or "",
		update_time = update_time_str or "",
		username = username_str or "",
	}
end

--------------------------------------------------------------------------------
-- A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
function M.create_api_leaderboard_record_list(
	next_cursor_str, -- 'string' () The cursor to send when retrieving the next page, if any.
	owner_records_arr, -- 'table' () A batched set of leaderboard records belonging to specified owners.
	prev_cursor_str, -- 'string' () The cursor to send when retrieving the previous page, if any.
	records_arr, -- 'table' () A list of leaderboard records.
	_)
	assert(not next_cursor_str or type(next_cursor_str) == "string", "Argument 'next_cursor_str' must be 'nil' or of type 'string'")
	assert(not owner_records_arr or type(owner_records_arr) == "table", "Argument 'owner_records_arr' must be 'nil' or of type 'table'")
	assert(not prev_cursor_str or type(prev_cursor_str) == "string", "Argument 'prev_cursor_str' must be 'nil' or of type 'string'")
	assert(not records_arr or type(records_arr) == "table", "Argument 'records_arr' must be 'nil' or of type 'table'")
	return {
		next_cursor = next_cursor_str or "",
		owner_records = owner_records_arr or {},
		prev_cursor = prev_cursor_str or "",
		records = records_arr or {},
	}
end

--------------------------------------------------------------------------------
-- Represents a realtime match.
function M.create_api_match(
	authoritative_bool, -- 'boolean' () True if it's an server-managed authoritative match, false otherwise.
	label_str, -- 'string' () Match label, if any.
	match_id_str, -- 'string' () The ID of the match, can be used to join.
	size_int, -- 'number' () Current number of users in the match.
	_)
	assert(not authoritative_bool or type(authoritative_bool) == "boolean", "Argument 'authoritative_bool' must be 'nil' or of type 'boolean'")
	assert(not label_str or type(label_str) == "string", "Argument 'label_str' must be 'nil' or of type 'string'")
	assert(not match_id_str or type(match_id_str) == "string", "Argument 'match_id_str' must be 'nil' or of type 'string'")
	assert(not size_int or type(size_int) == "number", "Argument 'size_int' must be 'nil' or of type 'number'")
	return {
		authoritative = authoritative_bool or false,
		label = label_str or "",
		match_id = match_id_str or "",
		size = size_int or 0,
	}
end

--------------------------------------------------------------------------------
-- A list of realtime matches.
function M.create_api_match_list(
	matches_arr, -- 'table' () A number of matches corresponding to a list operation.
	_)
	assert(not matches_arr or type(matches_arr) == "table", "Argument 'matches_arr' must be 'nil' or of type 'table'")
	return {
		matches = matches_arr or {},
	}
end

--------------------------------------------------------------------------------
-- A notification in the server.
function M.create_api_notification(
	code_int, -- 'number' () Category code for this notification.
	content_str, -- 'string' () Content of the notification in JSON.
	create_time_str, -- 'string' () The UNIX time when the notification was created.
	id_str, -- 'string' () ID of the Notification.
	persistent_bool, -- 'boolean' () True if this notification was persisted to the database.
	sender_id_str, -- 'string' () ID of the sender, if a user. Otherwise 'null'.
	subject_str, -- 'string' () Subject of the notification.
	_)
	assert(not code_int or type(code_int) == "number", "Argument 'code_int' must be 'nil' or of type 'number'")
	assert(not content_str or type(content_str) == "string", "Argument 'content_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not persistent_bool or type(persistent_bool) == "boolean", "Argument 'persistent_bool' must be 'nil' or of type 'boolean'")
	assert(not sender_id_str or type(sender_id_str) == "string", "Argument 'sender_id_str' must be 'nil' or of type 'string'")
	assert(not subject_str or type(subject_str) == "string", "Argument 'subject_str' must be 'nil' or of type 'string'")
	return {
		code = code_int or 0,
		content = content_str or "",
		create_time = create_time_str or "",
		id = id_str or "",
		persistent = persistent_bool or false,
		sender_id = sender_id_str or "",
		subject = subject_str or "",
	}
end

--------------------------------------------------------------------------------
-- A collection of zero or more notifications.
function M.create_api_notification_list(
	cacheable_cursor_str, -- 'string' () Use this cursor to paginate notifications. Cache this to catch up to new notifications.
	notifications_arr, -- 'table' () Collection of notifications.
	_)
	assert(not cacheable_cursor_str or type(cacheable_cursor_str) == "string", "Argument 'cacheable_cursor_str' must be 'nil' or of type 'string'")
	assert(not notifications_arr or type(notifications_arr) == "table", "Argument 'notifications_arr' must be 'nil' or of type 'table'")
	return {
		cacheable_cursor = cacheable_cursor_str or "",
		notifications = notifications_arr or {},
	}
end

--------------------------------------------------------------------------------
-- Storage objects to get.
function M.create_api_read_storage_object_id(
	collection_str, -- 'string' () The collection which stores the object.
	key_str, -- 'string' () The key of the object within the collection.
	user_id_str, -- 'string' () The user owner of the object.
	_)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not user_id_str or type(user_id_str) == "string", "Argument 'user_id_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		key = key_str or "",
		user_id = user_id_str or "",
	}
end

--------------------------------------------------------------------------------
-- Batch get storage objects.
function M.create_api_read_storage_objects_request(
	object_ids_arr, -- 'table' () Batch of storage objects.
	_)
	assert(not object_ids_arr or type(object_ids_arr) == "table", "Argument 'object_ids_arr' must be 'nil' or of type 'table'")
	return {
		object_ids = object_ids_arr or {},
	}
end

--------------------------------------------------------------------------------
-- Execute an Lua function on the server.
function M.create_api_rpc(
	http_key_str, -- 'string' () The authentication key used when executed as a non-client HTTP request.
	id_str, -- 'string' () The identifier of the function.
	payload_str, -- 'string' () The payload of the function which must be a JSON object.
	_)
	assert(not http_key_str or type(http_key_str) == "string", "Argument 'http_key_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not payload_str or type(payload_str) == "string", "Argument 'payload_str' must be 'nil' or of type 'string'")
	return {
		http_key = http_key_str or "",
		id = id_str or "",
		payload = payload_str or "",
	}
end

--------------------------------------------------------------------------------
-- A user's session used to authenticate messages.
function M.create_api_session(
	created_bool, -- 'boolean' () True if the corresponding account was just created, false otherwise.
	token_str, -- 'string' () Authentication credentials.
	_)
	assert(not created_bool or type(created_bool) == "boolean", "Argument 'created_bool' must be 'nil' or of type 'boolean'")
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	return {
		created = created_bool or false,
		token = token_str or "",
	}
end

--------------------------------------------------------------------------------
-- An object within the storage engine.
function M.create_api_storage_object(
	collection_str, -- 'string' () The collection which stores the object.
	create_time_str, -- 'string' () The UNIX time when the object was created.
	key_str, -- 'string' () The key of the object within the collection.
	permission_read_int, -- 'number' () The read access permissions for the object.
	permission_write_int, -- 'number' () The write access permissions for the object.
	update_time_str, -- 'string' () The UNIX time when the object was last updated.
	user_id_str, -- 'string' () The user owner of the object.
	value_str, -- 'string' () The value of the object.
	version_str, -- 'string' () The version hash of the object.
	_)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not permission_read_int or type(permission_read_int) == "number", "Argument 'permission_read_int' must be 'nil' or of type 'number'")
	assert(not permission_write_int or type(permission_write_int) == "number", "Argument 'permission_write_int' must be 'nil' or of type 'number'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not user_id_str or type(user_id_str) == "string", "Argument 'user_id_str' must be 'nil' or of type 'string'")
	assert(not value_str or type(value_str) == "string", "Argument 'value_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		create_time = create_time_str or "",
		key = key_str or "",
		permission_read = permission_read_int or 0,
		permission_write = permission_write_int or 0,
		update_time = update_time_str or "",
		user_id = user_id_str or "",
		value = value_str or "",
		version = version_str or "",
	}
end

--------------------------------------------------------------------------------
-- A storage acknowledgement.
function M.create_api_storage_object_ack(
	collection_str, -- 'string' () The collection which stores the object.
	key_str, -- 'string' () The key of the object within the collection.
	user_id_str, -- 'string' () The owner of the object.
	version_str, -- 'string' () The version hash of the object.
	_)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not user_id_str or type(user_id_str) == "string", "Argument 'user_id_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		key = key_str or "",
		user_id = user_id_str or "",
		version = version_str or "",
	}
end

--------------------------------------------------------------------------------
-- Batch of acknowledgements for the storage object write.
function M.create_api_storage_object_acks(
	acks_arr, -- 'table' () Batch of storage write acknowledgements.
	_)
	assert(not acks_arr or type(acks_arr) == "table", "Argument 'acks_arr' must be 'nil' or of type 'table'")
	return {
		acks = acks_arr or {},
	}
end

--------------------------------------------------------------------------------
-- List of storage objects.
function M.create_api_storage_object_list(
	cursor_str, -- 'string' () The cursor for the next page of results, if any.
	objects_arr, -- 'table' () The list of storage objects.
	_)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not objects_arr or type(objects_arr) == "table", "Argument 'objects_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		objects = objects_arr or {},
	}
end

--------------------------------------------------------------------------------
-- Batch of storage objects.
function M.create_api_storage_objects(
	objects_arr, -- 'table' () The batch of storage objects.
	_)
	assert(not objects_arr or type(objects_arr) == "table", "Argument 'objects_arr' must be 'nil' or of type 'table'")
	return {
		objects = objects_arr or {},
	}
end

--------------------------------------------------------------------------------
-- A tournament on the server.
function M.create_api_tournament(
	can_enter_bool, -- 'boolean' () True if the tournament is active and can enter. A computed value.
	category_int, -- 'number' () The category of the tournament. e.g. "vip" could be category 1.
	create_time_str, -- 'string' () The UNIX time when the tournament was created.
	description_str, -- 'string' () The description of the tournament. May be blank.
	duration_int, -- 'number' () Duration of the tournament in seconds.
	end_active_int, -- 'number' () The UNIX time when the tournament stops being active until next reset. A computed value.
	end_time_str, -- 'string' () The UNIX time when the tournament will be stopped.
	id_str, -- 'string' () The ID of the tournament.
	max_num_score_int, -- 'number' () The maximum score updates allowed per player for the current tournament.
	max_size_int, -- 'number' () The maximum number of players for the tournament.
	metadata_str, -- 'string' () Additional information stored as a JSON object.
	next_reset_int, -- 'number' () The UNIX time when the tournament is next playable. A computed value.
	size_int, -- 'number' () The current number of players in the tournament.
	sort_order_int, -- 'number' () ASC or DESC sort mode of scores in the tournament.
	start_active_int, -- 'number' () The UNIX time when the tournament start being active. A computed value.
	start_time_str, -- 'string' () The UNIX time when the tournament will start.
	title_str, -- 'string' () The title for the tournament.
	_)
	assert(not can_enter_bool or type(can_enter_bool) == "boolean", "Argument 'can_enter_bool' must be 'nil' or of type 'boolean'")
	assert(not category_int or type(category_int) == "number", "Argument 'category_int' must be 'nil' or of type 'number'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not duration_int or type(duration_int) == "number", "Argument 'duration_int' must be 'nil' or of type 'number'")
	assert(not end_active_int or type(end_active_int) == "number", "Argument 'end_active_int' must be 'nil' or of type 'number'")
	assert(not end_time_str or type(end_time_str) == "string", "Argument 'end_time_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not max_num_score_int or type(max_num_score_int) == "number", "Argument 'max_num_score_int' must be 'nil' or of type 'number'")
	assert(not max_size_int or type(max_size_int) == "number", "Argument 'max_size_int' must be 'nil' or of type 'number'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not next_reset_int or type(next_reset_int) == "number", "Argument 'next_reset_int' must be 'nil' or of type 'number'")
	assert(not size_int or type(size_int) == "number", "Argument 'size_int' must be 'nil' or of type 'number'")
	assert(not sort_order_int or type(sort_order_int) == "number", "Argument 'sort_order_int' must be 'nil' or of type 'number'")
	assert(not start_active_int or type(start_active_int) == "number", "Argument 'start_active_int' must be 'nil' or of type 'number'")
	assert(not start_time_str or type(start_time_str) == "string", "Argument 'start_time_str' must be 'nil' or of type 'string'")
	assert(not title_str or type(title_str) == "string", "Argument 'title_str' must be 'nil' or of type 'string'")
	return {
		can_enter = can_enter_bool or false,
		category = category_int or 0,
		create_time = create_time_str or "",
		description = description_str or "",
		duration = duration_int or 0,
		end_active = end_active_int or 0,
		end_time = end_time_str or "",
		id = id_str or "",
		max_num_score = max_num_score_int or 0,
		max_size = max_size_int or 0,
		metadata = metadata_str or "",
		next_reset = next_reset_int or 0,
		size = size_int or 0,
		sort_order = sort_order_int or 0,
		start_active = start_active_int or 0,
		start_time = start_time_str or "",
		title = title_str or "",
	}
end

--------------------------------------------------------------------------------
-- A list of tournaments.
function M.create_api_tournament_list(
	cursor_str, -- 'string' () A pagination cursor (optional).
	tournaments_arr, -- 'table' () The list of tournaments returned.
	_)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not tournaments_arr or type(tournaments_arr) == "table", "Argument 'tournaments_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		tournaments = tournaments_arr or {},
	}
end

--------------------------------------------------------------------------------
-- A set of tournament records which may be part of a tournament records page or a batch of individual records.
function M.create_api_tournament_record_list(
	next_cursor_str, -- 'string' () The cursor to send when retireving the next page (optional).
	owner_records_arr, -- 'table' () A batched set of tournament records belonging to specified owners.
	prev_cursor_str, -- 'string' () The cursor to send when retrieving the previous page (optional).
	records_arr, -- 'table' () A list of tournament records.
	_)
	assert(not next_cursor_str or type(next_cursor_str) == "string", "Argument 'next_cursor_str' must be 'nil' or of type 'string'")
	assert(not owner_records_arr or type(owner_records_arr) == "table", "Argument 'owner_records_arr' must be 'nil' or of type 'table'")
	assert(not prev_cursor_str or type(prev_cursor_str) == "string", "Argument 'prev_cursor_str' must be 'nil' or of type 'string'")
	assert(not records_arr or type(records_arr) == "table", "Argument 'records_arr' must be 'nil' or of type 'table'")
	return {
		next_cursor = next_cursor_str or "",
		owner_records = owner_records_arr or {},
		prev_cursor = prev_cursor_str or "",
		records = records_arr or {},
	}
end

--------------------------------------------------------------------------------
-- Update a user's account details.
function M.create_api_update_account_request(
	avatar_url_str, -- 'string' () A URL for an avatar image.
	display_name_str, -- 'string' () The display name of the user.
	lang_tag_str, -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	location_str, -- 'string' () The location set by the user.
	timezone_str, -- 'string' () The timezone set by the user.
	username_str, -- 'string' () The username of the user's account.
	_)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not display_name_str or type(display_name_str) == "string", "Argument 'display_name_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not location_str or type(location_str) == "string", "Argument 'location_str' must be 'nil' or of type 'string'")
	assert(not timezone_str or type(timezone_str) == "string", "Argument 'timezone_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		avatar_url = avatar_url_str or "",
		display_name = display_name_str or "",
		lang_tag = lang_tag_str or "",
		location = location_str or "",
		timezone = timezone_str or "",
		username = username_str or "",
	}
end

--------------------------------------------------------------------------------
-- Update fields in a given group.
function M.create_api_update_group_request(
	avatar_url_str, -- 'string' () Avatar URL.
	description_str, -- 'string' () Description string.
	group_id_str, -- 'string' () The ID of the group to update.
	lang_tag_str, -- 'string' () Lang tag.
	name_str, -- 'string' () Name.
	open_bool, -- 'boolean' () Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
	_)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not group_id_str or type(group_id_str) == "string", "Argument 'group_id_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not open_bool or type(open_bool) == "boolean", "Argument 'open_bool' must be 'nil' or of type 'boolean'")
	return {
		avatar_url = avatar_url_str or "",
		description = description_str or "",
		group_id = group_id_str or "",
		lang_tag = lang_tag_str or "",
		name = name_str or "",
		open = open_bool or false,
	}
end

--------------------------------------------------------------------------------
-- A user in the server.
function M.create_api_user(
	avatar_url_str, -- 'string' () A URL for an avatar image.
	create_time_str, -- 'string' () The UNIX time when the user was created.
	display_name_str, -- 'string' () The display name of the user.
	edge_count_int, -- 'number' () Number of related edges to this user.
	facebook_id_str, -- 'string' () The Facebook id in the user's account.
	facebook_instant_game_id_str, -- 'string' () The Facebook Instant Game id in the user's account.
	gamecenter_id_str, -- 'string' () The Apple Game Center in of the user's account.
	google_id_str, -- 'string' () The Google id in the user's account.
	id_str, -- 'string' () The id of the user's account.
	lang_tag_str, -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	location_str, -- 'string' () The location set by the user.
	metadata_str, -- 'string' () Additional information stored as a JSON object.
	online_bool, -- 'boolean' () Indicates whether the user is currently online.
	steam_id_str, -- 'string' () The Steam id in the user's account.
	timezone_str, -- 'string' () The timezone set by the user.
	update_time_str, -- 'string' () The UNIX time when the user was last updated.
	username_str, -- 'string' () The username of the user's account.
	_)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not display_name_str or type(display_name_str) == "string", "Argument 'display_name_str' must be 'nil' or of type 'string'")
	assert(not edge_count_int or type(edge_count_int) == "number", "Argument 'edge_count_int' must be 'nil' or of type 'number'")
	assert(not facebook_id_str or type(facebook_id_str) == "string", "Argument 'facebook_id_str' must be 'nil' or of type 'string'")
	assert(not facebook_instant_game_id_str or type(facebook_instant_game_id_str) == "string", "Argument 'facebook_instant_game_id_str' must be 'nil' or of type 'string'")
	assert(not gamecenter_id_str or type(gamecenter_id_str) == "string", "Argument 'gamecenter_id_str' must be 'nil' or of type 'string'")
	assert(not google_id_str or type(google_id_str) == "string", "Argument 'google_id_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not location_str or type(location_str) == "string", "Argument 'location_str' must be 'nil' or of type 'string'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not online_bool or type(online_bool) == "boolean", "Argument 'online_bool' must be 'nil' or of type 'boolean'")
	assert(not steam_id_str or type(steam_id_str) == "string", "Argument 'steam_id_str' must be 'nil' or of type 'string'")
	assert(not timezone_str or type(timezone_str) == "string", "Argument 'timezone_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		avatar_url = avatar_url_str or "",
		create_time = create_time_str or "",
		display_name = display_name_str or "",
		edge_count = edge_count_int or 0,
		facebook_id = facebook_id_str or "",
		facebook_instant_game_id = facebook_instant_game_id_str or "",
		gamecenter_id = gamecenter_id_str or "",
		google_id = google_id_str or "",
		id = id_str or "",
		lang_tag = lang_tag_str or "",
		location = location_str or "",
		metadata = metadata_str or "",
		online = online_bool or false,
		steam_id = steam_id_str or "",
		timezone = timezone_str or "",
		update_time = update_time_str or "",
		username = username_str or "",
	}
end

--------------------------------------------------------------------------------
-- A list of groups belonging to a user, along with the user's role in each group.
function M.create_api_user_group_list(
	cursor_str, -- 'string' () Cursor for the next page of results, if any.
	user_groups_arr, -- 'table' () Group-role pairs for a user.
	_)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not user_groups_arr or type(user_groups_arr) == "table", "Argument 'user_groups_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		user_groups = user_groups_arr or {},
	}
end

--------------------------------------------------------------------------------
-- A collection of zero or more users.
function M.create_api_users(
	users_arr, -- 'table' () The User objects.
	_)
	assert(not users_arr or type(users_arr) == "table", "Argument 'users_arr' must be 'nil' or of type 'table'")
	return {
		users = users_arr or {},
	}
end

--------------------------------------------------------------------------------
-- The object to store.
function M.create_api_write_storage_object(
	collection_str, -- 'string' () The collection to store the object.
	key_str, -- 'string' () The key for the object within the collection.
	permission_read_int, -- 'number' () The read access permissions for the object.
	permission_write_int, -- 'number' () The write access permissions for the object.
	value_str, -- 'string' () The value of the object.
	version_str, -- 'string' () The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
	_)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not permission_read_int or type(permission_read_int) == "number", "Argument 'permission_read_int' must be 'nil' or of type 'number'")
	assert(not permission_write_int or type(permission_write_int) == "number", "Argument 'permission_write_int' must be 'nil' or of type 'number'")
	assert(not value_str or type(value_str) == "string", "Argument 'value_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		key = key_str or "",
		permission_read = permission_read_int or 0,
		permission_write = permission_write_int or 0,
		value = value_str or "",
		version = version_str or "",
	}
end

--------------------------------------------------------------------------------
-- Write objects to the storage engine.
function M.create_api_write_storage_objects_request(
	objects_arr, -- 'table' () The objects to store on the server.
	_)
	assert(not objects_arr or type(objects_arr) == "table", "Argument 'objects_arr' must be 'nil' or of type 'table'")
	return {
		objects = objects_arr or {},
	}
end


--------------------------------------------------------------------------------
-- The low level client for the Nakama API.

local _http_fn = nil
local _config = {}

--
-- config.http_fn
-- config.base_uri
-- config.timeout
-- config.bearer_token
-- config.username
-- config.password
function M.init(config)
	assert(config, "You must provide a configuration")
	assert(config.base_uri, "You must provide a base URI")
	log("init()")

	_http_fn = config.http_fn or defold.http

	_config.base_uri = config.base_uri
	_config.bearer_token = config.bearer_token
	_config.username = config.username
	_config.password = config.password
	_config.timeout = config.timeout or 10
end

function M.sync(fn)
	local co = coroutine.create(fn)
	local ok, err = coroutine.resume(co)
	if not ok then
		log(err)
	end
end

function M.set_bearer_token(bearer_token)
	_config.bearer_token = bearer_token
end

-- A healthcheck which load balancers can use to check the service.
function M.healthcheck_async(
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("healthcheck_async()")

	local url_path = "/healthcheck"

	local query_params = {}

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		callback(result)
	end)
end
function M.healthcheck(
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.healthcheck_async(
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Fetch the current user's account.
function M.get_account_async(
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("get_account_async()")

	local url_path = "/v2/account"

	local query_params = {}

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_account then
			result = api_account.create(result)
		end
		callback(result)
	end)
end
function M.get_account(
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.get_account_async(
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Update fields in the current user's account.
function M.update_account_async(
	body_api_update_account_request, -- Type: table (api_update_account_request)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("update_account_async()")

	local url_path = "/v2/account"

	local query_params = {}
	local post_data = json.encode(body_api_update_account_request)

	_http_fn(_config, url_path, query_params, "PUT", post_data, function(result)
		callback(result)
	end)
end
function M.update_account(
	body_api_update_account_request -- Type: table (api_update_account_request)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.update_account_async(
		body_api_update_account_request,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Authenticate a user with a custom id against the server.
function M.authenticate_custom_async(
	body_api_account_custom, -- Type: table (api_account_custom)
	create_bool, -- Type: boolean
	username_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("authenticate_custom_async()")

	local url_path = "/v2/account/authenticate/custom"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_custom)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_session then
			result = api_session.create(result)
		end
		callback(result)
	end)
end
function M.authenticate_custom(
	body_api_account_custom -- Type: table (api_account_custom)
	,create_bool -- Type: boolean
	,username_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.authenticate_custom_async(
		body_api_account_custom,
		create_bool,
		username_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Authenticate a user with a device id against the server.
function M.authenticate_device_async(
	body_api_account_device, -- Type: table (api_account_device)
	create_bool, -- Type: boolean
	username_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("authenticate_device_async()")

	local url_path = "/v2/account/authenticate/device"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_device)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_session then
			result = api_session.create(result)
		end
		callback(result)
	end)
end
function M.authenticate_device(
	body_api_account_device -- Type: table (api_account_device)
	,create_bool -- Type: boolean
	,username_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.authenticate_device_async(
		body_api_account_device,
		create_bool,
		username_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Authenticate a user with an email+password against the server.
function M.authenticate_email_async(
	body_api_account_email, -- Type: table (api_account_email)
	create_bool, -- Type: boolean
	username_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("authenticate_email_async()")

	local url_path = "/v2/account/authenticate/email"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_email)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_session then
			result = api_session.create(result)
		end
		callback(result)
	end)
end
function M.authenticate_email(
	body_api_account_email -- Type: table (api_account_email)
	,create_bool -- Type: boolean
	,username_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.authenticate_email_async(
		body_api_account_email,
		create_bool,
		username_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Authenticate a user with a Facebook OAuth token against the server.
function M.authenticate_facebook_async(
	body_api_account_facebook, -- Type: table (api_account_facebook)
	create_bool, -- Type: boolean
	username_str, -- Type: string
	sync_bool, -- Type: boolean
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("authenticate_facebook_async()")

	local url_path = "/v2/account/authenticate/facebook"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	query_params["sync"] = sync_bool
	local post_data = json.encode(body_api_account_facebook)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_session then
			result = api_session.create(result)
		end
		callback(result)
	end)
end
function M.authenticate_facebook(
	body_api_account_facebook -- Type: table (api_account_facebook)
	,create_bool -- Type: boolean
	,username_str -- Type: string
	,sync_bool -- Type: boolean
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.authenticate_facebook_async(
		body_api_account_facebook,
		create_bool,
		username_str,
		sync_bool,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Authenticate a user with a Facebook Instant Game token against the server.
function M.authenticate_facebook_instant_game_async(
	body_api_account_facebook_instant_game, -- Type: table (api_account_facebook_instant_game)
	create_bool, -- Type: boolean
	username_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("authenticate_facebook_instant_game_async()")

	local url_path = "/v2/account/authenticate/facebookinstantgame"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_facebook_instant_game)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_session then
			result = api_session.create(result)
		end
		callback(result)
	end)
end
function M.authenticate_facebook_instant_game(
	body_api_account_facebook_instant_game -- Type: table (api_account_facebook_instant_game)
	,create_bool -- Type: boolean
	,username_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.authenticate_facebook_instant_game_async(
		body_api_account_facebook_instant_game,
		create_bool,
		username_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Authenticate a user with Apple's GameCenter against the server.
function M.authenticate_game_center_async(
	body_api_account_game_center, -- Type: table (api_account_game_center)
	create_bool, -- Type: boolean
	username_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("authenticate_game_center_async()")

	local url_path = "/v2/account/authenticate/gamecenter"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_game_center)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_session then
			result = api_session.create(result)
		end
		callback(result)
	end)
end
function M.authenticate_game_center(
	body_api_account_game_center -- Type: table (api_account_game_center)
	,create_bool -- Type: boolean
	,username_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.authenticate_game_center_async(
		body_api_account_game_center,
		create_bool,
		username_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Authenticate a user with Google against the server.
function M.authenticate_google_async(
	body_api_account_google, -- Type: table (api_account_google)
	create_bool, -- Type: boolean
	username_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("authenticate_google_async()")

	local url_path = "/v2/account/authenticate/google"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_google)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_session then
			result = api_session.create(result)
		end
		callback(result)
	end)
end
function M.authenticate_google(
	body_api_account_google -- Type: table (api_account_google)
	,create_bool -- Type: boolean
	,username_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.authenticate_google_async(
		body_api_account_google,
		create_bool,
		username_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Authenticate a user with Steam against the server.
function M.authenticate_steam_async(
	body_api_account_steam, -- Type: table (api_account_steam)
	create_bool, -- Type: boolean
	username_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("authenticate_steam_async()")

	local url_path = "/v2/account/authenticate/steam"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_steam)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_session then
			result = api_session.create(result)
		end
		callback(result)
	end)
end
function M.authenticate_steam(
	body_api_account_steam -- Type: table (api_account_steam)
	,create_bool -- Type: boolean
	,username_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.authenticate_steam_async(
		body_api_account_steam,
		create_bool,
		username_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add a custom ID to the social profiles on the current user's account.
function M.link_custom_async(
	body_api_account_custom, -- Type: table (api_account_custom)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("link_custom_async()")

	local url_path = "/v2/account/link/custom"

	local query_params = {}
	local post_data = json.encode(body_api_account_custom)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.link_custom(
	body_api_account_custom -- Type: table (api_account_custom)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.link_custom_async(
		body_api_account_custom,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add a device ID to the social profiles on the current user's account.
function M.link_device_async(
	body_api_account_device, -- Type: table (api_account_device)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("link_device_async()")

	local url_path = "/v2/account/link/device"

	local query_params = {}
	local post_data = json.encode(body_api_account_device)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.link_device(
	body_api_account_device -- Type: table (api_account_device)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.link_device_async(
		body_api_account_device,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add an email+password to the social profiles on the current user's account.
function M.link_email_async(
	body_api_account_email, -- Type: table (api_account_email)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("link_email_async()")

	local url_path = "/v2/account/link/email"

	local query_params = {}
	local post_data = json.encode(body_api_account_email)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.link_email(
	body_api_account_email -- Type: table (api_account_email)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.link_email_async(
		body_api_account_email,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add Facebook to the social profiles on the current user's account.
function M.link_facebook_async(
	body_api_account_facebook, -- Type: table (api_account_facebook)
	sync_bool, -- Type: boolean
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("link_facebook_async()")

	local url_path = "/v2/account/link/facebook"

	local query_params = {}
	query_params["sync"] = sync_bool
	local post_data = json.encode(body_api_account_facebook)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.link_facebook(
	body_api_account_facebook -- Type: table (api_account_facebook)
	,sync_bool -- Type: boolean
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.link_facebook_async(
		body_api_account_facebook,
		sync_bool,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add Facebook Instant Game to the social profiles on the current user's account.
function M.link_facebook_instant_game_async(
	body_api_account_facebook_instant_game, -- Type: table (api_account_facebook_instant_game)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("link_facebook_instant_game_async()")

	local url_path = "/v2/account/link/facebookinstantgame"

	local query_params = {}
	local post_data = json.encode(body_api_account_facebook_instant_game)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.link_facebook_instant_game(
	body_api_account_facebook_instant_game -- Type: table (api_account_facebook_instant_game)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.link_facebook_instant_game_async(
		body_api_account_facebook_instant_game,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add Apple's GameCenter to the social profiles on the current user's account.
function M.link_game_center_async(
	body_api_account_game_center, -- Type: table (api_account_game_center)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("link_game_center_async()")

	local url_path = "/v2/account/link/gamecenter"

	local query_params = {}
	local post_data = json.encode(body_api_account_game_center)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.link_game_center(
	body_api_account_game_center -- Type: table (api_account_game_center)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.link_game_center_async(
		body_api_account_game_center,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add Google to the social profiles on the current user's account.
function M.link_google_async(
	body_api_account_google, -- Type: table (api_account_google)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("link_google_async()")

	local url_path = "/v2/account/link/google"

	local query_params = {}
	local post_data = json.encode(body_api_account_google)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.link_google(
	body_api_account_google -- Type: table (api_account_google)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.link_google_async(
		body_api_account_google,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add Steam to the social profiles on the current user's account.
function M.link_steam_async(
	body_api_account_steam, -- Type: table (api_account_steam)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("link_steam_async()")

	local url_path = "/v2/account/link/steam"

	local query_params = {}
	local post_data = json.encode(body_api_account_steam)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.link_steam(
	body_api_account_steam -- Type: table (api_account_steam)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.link_steam_async(
		body_api_account_steam,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Remove the custom ID from the social profiles on the current user's account.
function M.unlink_custom_async(
	body_api_account_custom, -- Type: table (api_account_custom)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("unlink_custom_async()")

	local url_path = "/v2/account/unlink/custom"

	local query_params = {}
	local post_data = json.encode(body_api_account_custom)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.unlink_custom(
	body_api_account_custom -- Type: table (api_account_custom)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.unlink_custom_async(
		body_api_account_custom,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Remove the device ID from the social profiles on the current user's account.
function M.unlink_device_async(
	body_api_account_device, -- Type: table (api_account_device)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("unlink_device_async()")

	local url_path = "/v2/account/unlink/device"

	local query_params = {}
	local post_data = json.encode(body_api_account_device)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.unlink_device(
	body_api_account_device -- Type: table (api_account_device)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.unlink_device_async(
		body_api_account_device,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Remove the email+password from the social profiles on the current user's account.
function M.unlink_email_async(
	body_api_account_email, -- Type: table (api_account_email)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("unlink_email_async()")

	local url_path = "/v2/account/unlink/email"

	local query_params = {}
	local post_data = json.encode(body_api_account_email)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.unlink_email(
	body_api_account_email -- Type: table (api_account_email)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.unlink_email_async(
		body_api_account_email,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Remove Facebook from the social profiles on the current user's account.
function M.unlink_facebook_async(
	body_api_account_facebook, -- Type: table (api_account_facebook)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("unlink_facebook_async()")

	local url_path = "/v2/account/unlink/facebook"

	local query_params = {}
	local post_data = json.encode(body_api_account_facebook)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.unlink_facebook(
	body_api_account_facebook -- Type: table (api_account_facebook)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.unlink_facebook_async(
		body_api_account_facebook,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Remove Facebook Instant Game profile from the social profiles on the current user's account.
function M.unlink_facebook_instant_game_async(
	body_api_account_facebook_instant_game, -- Type: table (api_account_facebook_instant_game)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("unlink_facebook_instant_game_async()")

	local url_path = "/v2/account/unlink/facebookinstantgame"

	local query_params = {}
	local post_data = json.encode(body_api_account_facebook_instant_game)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.unlink_facebook_instant_game(
	body_api_account_facebook_instant_game -- Type: table (api_account_facebook_instant_game)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.unlink_facebook_instant_game_async(
		body_api_account_facebook_instant_game,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Remove Apple's GameCenter from the social profiles on the current user's account.
function M.unlink_game_center_async(
	body_api_account_game_center, -- Type: table (api_account_game_center)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("unlink_game_center_async()")

	local url_path = "/v2/account/unlink/gamecenter"

	local query_params = {}
	local post_data = json.encode(body_api_account_game_center)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.unlink_game_center(
	body_api_account_game_center -- Type: table (api_account_game_center)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.unlink_game_center_async(
		body_api_account_game_center,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Remove Google from the social profiles on the current user's account.
function M.unlink_google_async(
	body_api_account_google, -- Type: table (api_account_google)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("unlink_google_async()")

	local url_path = "/v2/account/unlink/google"

	local query_params = {}
	local post_data = json.encode(body_api_account_google)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.unlink_google(
	body_api_account_google -- Type: table (api_account_google)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.unlink_google_async(
		body_api_account_google,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Remove Steam from the social profiles on the current user's account.
function M.unlink_steam_async(
	body_api_account_steam, -- Type: table (api_account_steam)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("unlink_steam_async()")

	local url_path = "/v2/account/unlink/steam"

	local query_params = {}
	local post_data = json.encode(body_api_account_steam)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.unlink_steam(
	body_api_account_steam -- Type: table (api_account_steam)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.unlink_steam_async(
		body_api_account_steam,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List a channel's message history.
function M.list_channel_messages_async(
	channel_id_str, -- Type: string
	limit_int, -- Type: number
	forward_bool, -- Type: boolean
	cursor_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_channel_messages_async()")

	local url_path = "/v2/channel/{channel_id}"
	url_path = url_path.gsub("{channel_id}", uri_encode(channel_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["forward"] = forward_bool
	query_params["cursor"] = cursor_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_channel_message_list then
			result = api_channel_message_list.create(result)
		end
		callback(result)
	end)
end
function M.list_channel_messages(
	channel_id_str -- Type: string
	,limit_int -- Type: number
	,forward_bool -- Type: boolean
	,cursor_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_channel_messages_async(
		channel_id_str,
		limit_int,
		forward_bool,
		cursor_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Submit an event for processing in the server's registered runtime custom events handler.
function M.event_async(
	body_api_event, -- Type: table (api_event)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("event_async()")

	local url_path = "/v2/event"

	local query_params = {}
	local post_data = json.encode(body_api_event)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.event(
	body_api_event -- Type: table (api_event)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.event_async(
		body_api_event,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Delete one or more users by ID or username.
function M.delete_friends_async(
	ids_arr, -- Type: table (string)
	usernames_arr, -- Type: table (string)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("delete_friends_async()")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	_http_fn(_config, url_path, query_params, "DELETE", post_data, function(result)
		callback(result)
	end)
end
function M.delete_friends(
	ids_arr -- Type: table (string)
	,usernames_arr -- Type: table (string)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.delete_friends_async(
		ids_arr,
		usernames_arr,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List all friends for the current user.
function M.list_friends_async(
	limit_int, -- Type: number
	state_int, -- Type: number
	cursor_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_friends_async()")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_friend_list then
			result = api_friend_list.create(result)
		end
		callback(result)
	end)
end
function M.list_friends(
	limit_int -- Type: number
	,state_int -- Type: number
	,cursor_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_friends_async(
		limit_int,
		state_int,
		cursor_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add friends by ID or username to a user's account.
function M.add_friends_async(
	ids_arr, -- Type: table (string)
	usernames_arr, -- Type: table (string)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("add_friends_async()")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.add_friends(
	ids_arr -- Type: table (string)
	,usernames_arr -- Type: table (string)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.add_friends_async(
		ids_arr,
		usernames_arr,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Block one or more users by ID or username.
function M.block_friends_async(
	ids_arr, -- Type: table (string)
	usernames_arr, -- Type: table (string)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("block_friends_async()")

	local url_path = "/v2/friend/block"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.block_friends(
	ids_arr -- Type: table (string)
	,usernames_arr -- Type: table (string)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.block_friends_async(
		ids_arr,
		usernames_arr,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Import Facebook friends and add them to a user's account.
function M.import_facebook_friends_async(
	body_api_account_facebook, -- Type: table (api_account_facebook)
	reset_bool, -- Type: boolean
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("import_facebook_friends_async()")

	local url_path = "/v2/friend/facebook"

	local query_params = {}
	query_params["reset"] = reset_bool
	local post_data = json.encode(body_api_account_facebook)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.import_facebook_friends(
	body_api_account_facebook -- Type: table (api_account_facebook)
	,reset_bool -- Type: boolean
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.import_facebook_friends_async(
		body_api_account_facebook,
		reset_bool,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List groups based on given filters.
function M.list_groups_async(
	name_str, -- Type: string
	cursor_str, -- Type: string
	limit_int, -- Type: number
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_groups_async()")

	local url_path = "/v2/group"

	local query_params = {}
	query_params["name"] = name_str
	query_params["cursor"] = cursor_str
	query_params["limit"] = limit_int

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_group_list then
			result = api_group_list.create(result)
		end
		callback(result)
	end)
end
function M.list_groups(
	name_str -- Type: string
	,cursor_str -- Type: string
	,limit_int -- Type: number
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_groups_async(
		name_str,
		cursor_str,
		limit_int,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Create a new group with the current user as the owner.
function M.create_group_async(
	body_api_create_group_request, -- Type: table (api_create_group_request)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("create_group_async()")

	local url_path = "/v2/group"

	local query_params = {}
	local post_data = json.encode(body_api_create_group_request)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_group then
			result = api_group.create(result)
		end
		callback(result)
	end)
end
function M.create_group(
	body_api_create_group_request -- Type: table (api_create_group_request)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.create_group_async(
		body_api_create_group_request,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Delete a group by ID.
function M.delete_group_async(
	group_id_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("delete_group_async()")

	local url_path = "/v2/group/{group_id}"
	url_path = url_path.gsub("{group_id}", uri_encode(group_id_str))

	local query_params = {}

	_http_fn(_config, url_path, query_params, "DELETE", post_data, function(result)
		callback(result)
	end)
end
function M.delete_group(
	group_id_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.delete_group_async(
		group_id_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Update fields in a given group.
function M.update_group_async(
	group_id_str, -- Type: string
	body_api_update_group_request, -- Type: table (api_update_group_request)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("update_group_async()")

	local url_path = "/v2/group/{group_id}"
	url_path = url_path.gsub("{group_id}", uri_encode(group_id_str))

	local query_params = {}
	local post_data = json.encode(body_api_update_group_request)

	_http_fn(_config, url_path, query_params, "PUT", post_data, function(result)
		callback(result)
	end)
end
function M.update_group(
	group_id_str -- Type: string
	,body_api_update_group_request -- Type: table (api_update_group_request)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.update_group_async(
		group_id_str,
		body_api_update_group_request,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Add users to a group.
function M.add_group_users_async(
	group_id_str, -- Type: string
	user_ids_arr, -- Type: table (string)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("add_group_users_async()")

	local url_path = "/v2/group/{group_id}/add"
	url_path = url_path.gsub("{group_id}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.add_group_users(
	group_id_str -- Type: string
	,user_ids_arr -- Type: table (string)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.add_group_users_async(
		group_id_str,
		user_ids_arr,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Ban a set of users from a group.
function M.ban_group_users_async(
	group_id_str, -- Type: string
	user_ids_arr, -- Type: table (string)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("ban_group_users_async()")

	local url_path = "/v2/group/{group_id}/ban"
	url_path = url_path.gsub("{group_id}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.ban_group_users(
	group_id_str -- Type: string
	,user_ids_arr -- Type: table (string)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.ban_group_users_async(
		group_id_str,
		user_ids_arr,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Immediately join an open group, or request to join a closed one.
function M.join_group_async(
	group_id_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("join_group_async()")

	local url_path = "/v2/group/{group_id}/join"
	url_path = url_path.gsub("{group_id}", uri_encode(group_id_str))

	local query_params = {}

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.join_group(
	group_id_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.join_group_async(
		group_id_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Kick a set of users from a group.
function M.kick_group_users_async(
	group_id_str, -- Type: string
	user_ids_arr, -- Type: table (string)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("kick_group_users_async()")

	local url_path = "/v2/group/{group_id}/kick"
	url_path = url_path.gsub("{group_id}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.kick_group_users(
	group_id_str -- Type: string
	,user_ids_arr -- Type: table (string)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.kick_group_users_async(
		group_id_str,
		user_ids_arr,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Leave a group the user is a member of.
function M.leave_group_async(
	group_id_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("leave_group_async()")

	local url_path = "/v2/group/{group_id}/leave"
	url_path = url_path.gsub("{group_id}", uri_encode(group_id_str))

	local query_params = {}

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.leave_group(
	group_id_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.leave_group_async(
		group_id_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Promote a set of users in a group to the next role up.
function M.promote_group_users_async(
	group_id_str, -- Type: string
	user_ids_arr, -- Type: table (string)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("promote_group_users_async()")

	local url_path = "/v2/group/{group_id}/promote"
	url_path = url_path.gsub("{group_id}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.promote_group_users(
	group_id_str -- Type: string
	,user_ids_arr -- Type: table (string)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.promote_group_users_async(
		group_id_str,
		user_ids_arr,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List all users that are part of a group.
function M.list_group_users_async(
	group_id_str, -- Type: string
	limit_int, -- Type: number
	state_int, -- Type: number
	cursor_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_group_users_async()")

	local url_path = "/v2/group/{group_id}/user"
	url_path = url_path.gsub("{group_id}", uri_encode(group_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_group_user_list then
			result = api_group_user_list.create(result)
		end
		callback(result)
	end)
end
function M.list_group_users(
	group_id_str -- Type: string
	,limit_int -- Type: number
	,state_int -- Type: number
	,cursor_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_group_users_async(
		group_id_str,
		limit_int,
		state_int,
		cursor_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Delete a leaderboard record.
function M.delete_leaderboard_record_async(
	leaderboard_id_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("delete_leaderboard_record_async()")

	local url_path = "/v2/leaderboard/{leaderboard_id}"
	url_path = url_path.gsub("{leaderboard_id}", uri_encode(leaderboard_id_str))

	local query_params = {}

	_http_fn(_config, url_path, query_params, "DELETE", post_data, function(result)
		callback(result)
	end)
end
function M.delete_leaderboard_record(
	leaderboard_id_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.delete_leaderboard_record_async(
		leaderboard_id_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List leaderboard records.
function M.list_leaderboard_records_async(
	leaderboard_id_str, -- Type: string
	owner_ids_arr, -- Type: table (string)
	limit_int, -- Type: number
	cursor_str, -- Type: string
	expiry_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_leaderboard_records_async()")

	local url_path = "/v2/leaderboard/{leaderboard_id}"
	url_path = url_path.gsub("{leaderboard_id}", uri_encode(leaderboard_id_str))

	local query_params = {}
	query_params["owner_ids"] = owner_ids_arr
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str
	query_params["expiry"] = expiry_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_leaderboard_record_list then
			result = api_leaderboard_record_list.create(result)
		end
		callback(result)
	end)
end
function M.list_leaderboard_records(
	leaderboard_id_str -- Type: string
	,owner_ids_arr -- Type: table (string)
	,limit_int -- Type: number
	,cursor_str -- Type: string
	,expiry_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_leaderboard_records_async(
		leaderboard_id_str,
		owner_ids_arr,
		limit_int,
		cursor_str,
		expiry_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Write a record to a leaderboard.
function M.write_leaderboard_record_async(
	leaderboard_id_str, -- Type: string
	body_write_leaderboard_record_request_leaderboard_record_write, -- Type: table (write_leaderboard_record_request_leaderboard_record_write)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("write_leaderboard_record_async()")

	local url_path = "/v2/leaderboard/{leaderboard_id}"
	url_path = url_path.gsub("{leaderboard_id}", uri_encode(leaderboard_id_str))

	local query_params = {}
	local post_data = json.encode(body_write_leaderboard_record_request_leaderboard_record_write)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_leaderboard_record then
			result = api_leaderboard_record.create(result)
		end
		callback(result)
	end)
end
function M.write_leaderboard_record(
	leaderboard_id_str -- Type: string
	,body_write_leaderboard_record_request_leaderboard_record_write -- Type: table (write_leaderboard_record_request_leaderboard_record_write)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.write_leaderboard_record_async(
		leaderboard_id_str,
		body_write_leaderboard_record_request_leaderboard_record_write,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List leaderboard records that belong to a user.
function M.list_leaderboard_records_around_owner_async(
	leaderboard_id_str, -- Type: string
	owner_id_str, -- Type: string
	limit_int, -- Type: number
	expiry_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_leaderboard_records_around_owner_async()")

	local url_path = "/v2/leaderboard/{leaderboard_id}/owner/{owner_id}"
	url_path = url_path.gsub("{leaderboard_id}", uri_encode(leaderboard_id_str))
	url_path = url_path.gsub("{owner_id}", uri_encode(owner_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["expiry"] = expiry_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_leaderboard_record_list then
			result = api_leaderboard_record_list.create(result)
		end
		callback(result)
	end)
end
function M.list_leaderboard_records_around_owner(
	leaderboard_id_str -- Type: string
	,owner_id_str -- Type: string
	,limit_int -- Type: number
	,expiry_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_leaderboard_records_around_owner_async(
		leaderboard_id_str,
		owner_id_str,
		limit_int,
		expiry_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Fetch list of running matches.
function M.list_matches_async(
	limit_int, -- Type: number
	authoritative_bool, -- Type: boolean
	label_str, -- Type: string
	min_size_int, -- Type: number
	max_size_int, -- Type: number
	query_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_matches_async()")

	local url_path = "/v2/match"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["authoritative"] = authoritative_bool
	query_params["label"] = label_str
	query_params["min_size"] = min_size_int
	query_params["max_size"] = max_size_int
	query_params["query"] = query_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_match_list then
			result = api_match_list.create(result)
		end
		callback(result)
	end)
end
function M.list_matches(
	limit_int -- Type: number
	,authoritative_bool -- Type: boolean
	,label_str -- Type: string
	,min_size_int -- Type: number
	,max_size_int -- Type: number
	,query_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_matches_async(
		limit_int,
		authoritative_bool,
		label_str,
		min_size_int,
		max_size_int,
		query_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Delete one or more notifications for the current user.
function M.delete_notifications_async(
	ids_arr, -- Type: table (string)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("delete_notifications_async()")

	local url_path = "/v2/notification"

	local query_params = {}
	query_params["ids"] = ids_arr

	_http_fn(_config, url_path, query_params, "DELETE", post_data, function(result)
		callback(result)
	end)
end
function M.delete_notifications(
	ids_arr -- Type: table (string)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.delete_notifications_async(
		ids_arr,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Fetch list of notifications.
function M.list_notifications_async(
	limit_int, -- Type: number
	cacheable_cursor_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_notifications_async()")

	local url_path = "/v2/notification"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["cacheable_cursor"] = cacheable_cursor_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_notification_list then
			result = api_notification_list.create(result)
		end
		callback(result)
	end)
end
function M.list_notifications(
	limit_int -- Type: number
	,cacheable_cursor_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_notifications_async(
		limit_int,
		cacheable_cursor_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Execute a Lua function on the server.
function M.rpc_func2_async(
	id_str, -- Type: string
	payload_str, -- Type: string
	http_key_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("rpc_func2_async()")

	local url_path = "/v2/rpc/{id}"
	url_path = url_path.gsub("{id}", uri_encode(id_str))

	local query_params = {}
	query_params["payload"] = payload_str
	query_params["http_key"] = http_key_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_rpc then
			result = api_rpc.create(result)
		end
		callback(result)
	end)
end
function M.rpc_func2(
	id_str -- Type: string
	,payload_str -- Type: string
	,http_key_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.rpc_func2_async(
		id_str,
		payload_str,
		http_key_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Execute a Lua function on the server.
function M.rpc_func_async(
	id_str, -- Type: string
	body_, -- Type: table ()
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("rpc_func_async()")

	local url_path = "/v2/rpc/{id}"
	url_path = url_path.gsub("{id}", uri_encode(id_str))

	local query_params = {}
	local post_data = json.encode(body_)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_rpc then
			result = api_rpc.create(result)
		end
		callback(result)
	end)
end
function M.rpc_func(
	id_str -- Type: string
	,body_ -- Type: table ()
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.rpc_func_async(
		id_str,
		body_,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Get storage objects.
function M.read_storage_objects_async(
	body_api_read_storage_objects_request, -- Type: table (api_read_storage_objects_request)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("read_storage_objects_async()")

	local url_path = "/v2/storage"

	local query_params = {}
	local post_data = json.encode(body_api_read_storage_objects_request)

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		if not result.error and api_storage_objects then
			result = api_storage_objects.create(result)
		end
		callback(result)
	end)
end
function M.read_storage_objects(
	body_api_read_storage_objects_request -- Type: table (api_read_storage_objects_request)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.read_storage_objects_async(
		body_api_read_storage_objects_request,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Write objects into the storage engine.
function M.write_storage_objects_async(
	body_api_write_storage_objects_request, -- Type: table (api_write_storage_objects_request)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("write_storage_objects_async()")

	local url_path = "/v2/storage"

	local query_params = {}
	local post_data = json.encode(body_api_write_storage_objects_request)

	_http_fn(_config, url_path, query_params, "PUT", post_data, function(result)
		if not result.error and api_storage_object_acks then
			result = api_storage_object_acks.create(result)
		end
		callback(result)
	end)
end
function M.write_storage_objects(
	body_api_write_storage_objects_request -- Type: table (api_write_storage_objects_request)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.write_storage_objects_async(
		body_api_write_storage_objects_request,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Delete one or more objects by ID or username.
function M.delete_storage_objects_async(
	body_api_delete_storage_objects_request, -- Type: table (api_delete_storage_objects_request)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("delete_storage_objects_async()")

	local url_path = "/v2/storage/delete"

	local query_params = {}
	local post_data = json.encode(body_api_delete_storage_objects_request)

	_http_fn(_config, url_path, query_params, "PUT", post_data, function(result)
		callback(result)
	end)
end
function M.delete_storage_objects(
	body_api_delete_storage_objects_request -- Type: table (api_delete_storage_objects_request)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.delete_storage_objects_async(
		body_api_delete_storage_objects_request,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List publicly readable storage objects in a given collection.
function M.list_storage_objects_async(
	collection_str, -- Type: string
	user_id_str, -- Type: string
	limit_int, -- Type: number
	cursor_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_storage_objects_async()")

	local url_path = "/v2/storage/{collection}"
	url_path = url_path.gsub("{collection}", uri_encode(collection_str))

	local query_params = {}
	query_params["user_id"] = user_id_str
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_storage_object_list then
			result = api_storage_object_list.create(result)
		end
		callback(result)
	end)
end
function M.list_storage_objects(
	collection_str -- Type: string
	,user_id_str -- Type: string
	,limit_int -- Type: number
	,cursor_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_storage_objects_async(
		collection_str,
		user_id_str,
		limit_int,
		cursor_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List publicly readable storage objects in a given collection.
function M.list_storage_objects2_async(
	collection_str, -- Type: string
	user_id_str, -- Type: string
	limit_int, -- Type: number
	cursor_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_storage_objects2_async()")

	local url_path = "/v2/storage/{collection}/{user_id}"
	url_path = url_path.gsub("{collection}", uri_encode(collection_str))
	url_path = url_path.gsub("{user_id}", uri_encode(user_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_storage_object_list then
			result = api_storage_object_list.create(result)
		end
		callback(result)
	end)
end
function M.list_storage_objects2(
	collection_str -- Type: string
	,user_id_str -- Type: string
	,limit_int -- Type: number
	,cursor_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_storage_objects2_async(
		collection_str,
		user_id_str,
		limit_int,
		cursor_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List current or upcoming tournaments.
function M.list_tournaments_async(
	category_start_int, -- Type: number
	category_end_int, -- Type: number
	start_time_int, -- Type: number
	end_time_int, -- Type: number
	limit_int, -- Type: number
	cursor_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_tournaments_async()")

	local url_path = "/v2/tournament"

	local query_params = {}
	query_params["category_start"] = category_start_int
	query_params["category_end"] = category_end_int
	query_params["start_time"] = start_time_int
	query_params["end_time"] = end_time_int
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_tournament_list then
			result = api_tournament_list.create(result)
		end
		callback(result)
	end)
end
function M.list_tournaments(
	category_start_int -- Type: number
	,category_end_int -- Type: number
	,start_time_int -- Type: number
	,end_time_int -- Type: number
	,limit_int -- Type: number
	,cursor_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_tournaments_async(
		category_start_int,
		category_end_int,
		start_time_int,
		end_time_int,
		limit_int,
		cursor_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List tournament records.
function M.list_tournament_records_async(
	tournament_id_str, -- Type: string
	owner_ids_arr, -- Type: table (string)
	limit_int, -- Type: number
	cursor_str, -- Type: string
	expiry_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_tournament_records_async()")

	local url_path = "/v2/tournament/{tournament_id}"
	url_path = url_path.gsub("{tournament_id}", uri_encode(tournament_id_str))

	local query_params = {}
	query_params["owner_ids"] = owner_ids_arr
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str
	query_params["expiry"] = expiry_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_tournament_record_list then
			result = api_tournament_record_list.create(result)
		end
		callback(result)
	end)
end
function M.list_tournament_records(
	tournament_id_str -- Type: string
	,owner_ids_arr -- Type: table (string)
	,limit_int -- Type: number
	,cursor_str -- Type: string
	,expiry_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_tournament_records_async(
		tournament_id_str,
		owner_ids_arr,
		limit_int,
		cursor_str,
		expiry_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Write a record to a tournament.
function M.write_tournament_record_async(
	tournament_id_str, -- Type: string
	body_write_tournament_record_request_tournament_record_write, -- Type: table (write_tournament_record_request_tournament_record_write)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("write_tournament_record_async()")

	local url_path = "/v2/tournament/{tournament_id}"
	url_path = url_path.gsub("{tournament_id}", uri_encode(tournament_id_str))

	local query_params = {}
	local post_data = json.encode(body_write_tournament_record_request_tournament_record_write)

	_http_fn(_config, url_path, query_params, "PUT", post_data, function(result)
		if not result.error and api_leaderboard_record then
			result = api_leaderboard_record.create(result)
		end
		callback(result)
	end)
end
function M.write_tournament_record(
	tournament_id_str -- Type: string
	,body_write_tournament_record_request_tournament_record_write -- Type: table (write_tournament_record_request_tournament_record_write)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.write_tournament_record_async(
		tournament_id_str,
		body_write_tournament_record_request_tournament_record_write,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Attempt to join an open and running tournament.
function M.join_tournament_async(
	tournament_id_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("join_tournament_async()")

	local url_path = "/v2/tournament/{tournament_id}/join"
	url_path = url_path.gsub("{tournament_id}", uri_encode(tournament_id_str))

	local query_params = {}

	_http_fn(_config, url_path, query_params, "POST", post_data, function(result)
		callback(result)
	end)
end
function M.join_tournament(
	tournament_id_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.join_tournament_async(
		tournament_id_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List tournament records for a given owner.
function M.list_tournament_records_around_owner_async(
	tournament_id_str, -- Type: string
	owner_id_str, -- Type: string
	limit_int, -- Type: number
	expiry_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_tournament_records_around_owner_async()")

	local url_path = "/v2/tournament/{tournament_id}/owner/{owner_id}"
	url_path = url_path.gsub("{tournament_id}", uri_encode(tournament_id_str))
	url_path = url_path.gsub("{owner_id}", uri_encode(owner_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["expiry"] = expiry_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_tournament_record_list then
			result = api_tournament_record_list.create(result)
		end
		callback(result)
	end)
end
function M.list_tournament_records_around_owner(
	tournament_id_str -- Type: string
	,owner_id_str -- Type: string
	,limit_int -- Type: number
	,expiry_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_tournament_records_around_owner_async(
		tournament_id_str,
		owner_id_str,
		limit_int,
		expiry_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- Fetch zero or more users by ID and/or username.
function M.get_users_async(
	ids_arr, -- Type: table (string)
	usernames_arr, -- Type: table (string)
	facebook_ids_arr, -- Type: table (string)
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("get_users_async()")

	local url_path = "/v2/user"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr
	query_params["facebook_ids"] = facebook_ids_arr

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_users then
			result = api_users.create(result)
		end
		callback(result)
	end)
end
function M.get_users(
	ids_arr -- Type: table (string)
	,usernames_arr -- Type: table (string)
	,facebook_ids_arr -- Type: table (string)
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.get_users_async(
		ids_arr,
		usernames_arr,
		facebook_ids_arr,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

-- List groups the current user belongs to.
function M.list_user_groups_async(
	user_id_str, -- Type: string
	limit_int, -- Type: number
	state_int, -- Type: number
	cursor_str, -- Type: string
	callback)
	assert(_config, "Client is not initialized")
	assert(callback, "You must provide a callback")
	log("list_user_groups_async()")

	local url_path = "/v2/user/{user_id}/group"
	url_path = url_path.gsub("{user_id}", uri_encode(user_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	_http_fn(_config, url_path, query_params, "GET", post_data, function(result)
		if not result.error and api_user_group_list then
			result = api_user_group_list.create(result)
		end
		callback(result)
	end)
end
function M.list_user_groups(
	user_id_str -- Type: string
	,limit_int -- Type: number
	,state_int -- Type: number
	,cursor_str -- Type: string
	)
	local co = coroutine.running()
	assert(co, "You must run this from a coroutine")

	M.list_user_groups_async(
		user_id_str,
		limit_int,
		state_int,
		cursor_str,
		function(result)
			local ok, err = coroutine.resume(co, result)
			if not ok then
				print(err)
			end
		end)

	local result = coroutine.yield()
	return result
end

return M
